use std.{system.panic, memory};
use os.winapi;

use d3d11;

@[link_name=OpenProcess]
native func open_process(
	winapi.Dword,
	winapi.Bool,
	winapi.Dword,
) -> addr;

@[link_name=DuplicateHandle]
native func duplicate_handle(
	winapi.Handle,
	winapi.Handle,
	winapi.Handle,
	*winapi.Handle,
	winapi.Dword,
	winapi.Bool,
	winapi.Dword,
) -> winapi.Bool;

@[link_name=GetCurrentProcess]
native func get_current_process() -> winapi.Handle;

struct SharedImage {
	var id: u32;
	var texture: *d3d11.Texture2D;
	var mutex: *d3d11.DXGIKeyedMutex;
}

struct DisplaySurface {
	var device1: *d3d11.Device1;
	var device_context: *d3d11.DeviceContext;
	var buffer: *d3d11.Texture2D;
	var swapchain: *d3d11.DXGISwapChain1;
	var images: Array[SharedImage];

	pub func create(hwnd: winapi.Handle) -> *DisplaySurface {
		var guid_dxgi_resource_1 = (
			0x30961379 as u32,
			0x4609 as u16,
			0x4a41 as u16,
			0x99 as u8,
			0x8e as u8,
			0x54 as u8,
			0xFE as u8,
			0x56 as u8,
			0x7E as u8,
			0xE0 as u8,
			0xC1 as u8,
		);
        
        var guid_dxgi_factory_2 = (
            0x50C83A1C as u32,
            0xE072 as u16,
            0x4C48 as u16,
            0x87 as u8,
            0xB0 as u8,
            0x36 as u8,
            0x30 as u8,
            0xFA as u8,
            0x36 as u8,
            0xA6 as u8,
            0xD0 as u8,
        );

		var factory: *d3d11.DXGIFactory2;

		if d3d11.create_dxgifactory1(&guid_dxgi_factory_2, &factory as *addr) != 0 {
			panic("Failed to create DXGI factory");
		}

		var adapter: *d3d11.DXGIAdapter;
		if factory.vtable.enum_adapters(factory, 0, &adapter) == 0x887A0002 {
			panic("Failed to enumerate DXGI adapters");
		}

		factory.vtable.release(factory);

		var desc: d3d11.DXGIAdapterDesc;
		if adapter.vtable.get_desc(adapter, &desc) != 0 {
			panic("Failed to get DXGI adapter description");
		}

		print("Using adapter with LUID ");
		println(desc.adapter_luid);

		var feature_level = d3d11.FeatureLevel._11_1;
		var device: *d3d11.Device;
		var device_context: *d3d11.DeviceContext;

		if d3d11.d3_d11_create_device(
			adapter,
			d3d11.DriverType.TYPE_UNKNOWN,
			null,
			2,
			&feature_level,
			1,
			7,
			&device,
			null,
			&device_context
		) != 0 {
			panic("Failed to create D3D11 device");
		}

		println("Device created");

		var guid_d3d11_device_1 = (
			0xA04BFB29 as u32,
			0x08EF as u16,
			0x43D6 as u16,
			0xA4 as u8,
			0x9C as u8,
			0xA9 as u8,
			0xBD as u8,
			0xBD as u8,
			0xCB as u8,
			0xE6 as u8,
			0x86 as u8,
		);

		var device1: *d3d11.Device1;

		if device.vtable.query_interface(device, &guid_d3d11_device_1, &device1 as *addr) != 0 {
			panic("Failed to access ID3D11Device1 interface");
		}

		println("Accessed ID3D11Device1 interface");

		var swapchain_desc = d3d11.DXGISwapChainDesc1 {
			width: 1080,
			height: 1080,
			format: d3d11.DXGIFormat.R8G8B8A8_UNORM,
			stereo: 0,
			sample_desc: d3d11.DXGISampleDesc {
				count: 1,
				quality: 0,
			},
			buffer_usage:
				# d3d11.DXGI_USAGE_RENDER_TARGET_OUTPUT as u32 |
				d3d11.DXGI_USAGE_UNORDERED_ACCESS as u32,
			buffer_count: 2,
			swap_effect: d3d11.DXGISwapEffect.FLIP_DISCARD,
			scaling: d3d11.DXGIScaling.STRETCH,
			alpha_mode: d3d11.DXGIAlphaMode.MODE_UNSPECIFIED,
			flags: 0,
		};

		var swapchain: *d3d11.DXGISwapChain1;

		if factory.vtable.create_swap_chain_for_hwnd(
			factory,
			device,
			hwnd,
			&swapchain_desc,
			null,
			null,
			&swapchain,
		) != 0 {
			panic("Failed to create swapchain");
		}

		println("Swapchain created");

		var buffer: *d3d11.Texture2D;

		var guid_texture_2d: (u32, u16, u16, u8, u8, u8, u8, u8, u8, u8, u8) = (
			0x6F15AAF2,
			0xD208,
			0x4E89,
			0x9A,
			0xB4,
			0x48,
			0x95,
			0x35,
			0xD3,
			0x4F,
			0x9C,
		);

		if swapchain.vtable.get_buffer(swapchain, 0, &guid_texture_2d, &buffer as *addr) != 0 {
			panic("Failed to get swapchain buffer");
		}

		println("Got swapchain buffer");

		return memory.box(DisplaySurface {
			device1,
			device_context,
			buffer,
			swapchain,
			images: [],
		});
	}

	pub func register_image(
		self,
		id: u32,
		target_process_id: winapi.Dword,
		shared_texture_handle: winapi.Handle
	) {
		var guid_texture_2d: (u32, u16, u16, u8, u8, u8, u8, u8, u8, u8, u8) = (
			0x6F15AAF2,
			0xD208,
			0x4E89,
			0x9A,
			0xB4,
			0x48,
			0x95,
			0x35,
			0xD3,
			0x4F,
			0x9C,
		);

		var guid_dxgi_keyed_mutex = (
			0x9D8E1289 as u32,
			0xD7B3 as u16,
			0x465F as u16,
			0x81 as u8,
			0x26 as u8,
			0x25 as u8,
			0x0E as u8,
			0x34 as u8,
			0x9A as u8,
			0xF8 as u8,
			0x5D as u8,
		);

		var process = open_process(0x40, 0, target_process_id);

		if process == null {
			panic("Failed to open target process");
		}

		println("Opened target process");

		var local_handle: addr = null;

		if duplicate_handle(process, shared_texture_handle, get_current_process(), &local_handle, 0, 0, 0x2) == 0 {
			panic("Failed to duplicate handle");
		}

		println("Handle duplicated");

		if !winapi.close_handle(process) {
			panic("Failed to close process handle");
		}

		println("Process handle closed");

		var texture: *d3d11.Texture2D;

		if self.device1.vtable.open_shared_resource1(self.device1, local_handle, &guid_texture_2d, &texture as *addr) != 0 {
			panic("Failed to open foreign texture");
		}

		println("Opened foreign texture");

		var mutex: *d3d11.DXGIKeyedMutex;

		if texture.vtable.query_interface(texture, &guid_dxgi_keyed_mutex, &mutex as *addr) != 0 {
			panic("Failed to access IDXGIKeyedMutex interface");
		}

		println("Accessed IDXGIKeyedMutex interface");

		self.images.append(SharedImage { id, texture, mutex });
	}

	pub func present_image(self, id: u32) {
		var guid_d3d11_resource = (
			0xDC8E63F3 as u32,
			0xD12B as u16,
			0x4952 as u16,
			0xB4 as u8,
			0x7B as u8,
			0x5E as u8,
			0x45 as u8,
			0x02 as u8,
			0x6A as u8,
			0x86 as u8,
			0x2D as u8,
		);

		var shared_image: *SharedImage = null;
		
		for *image in self.images {
			if image.id == id {
				shared_image = image;
			}
		}

		if shared_image == null {
			return;
		}

		var destination: *d3d11.Resource;
		if self.buffer.vtable.query_interface(self.buffer, &guid_d3d11_resource, &destination as *addr) != 0 {
			panic("Failed to query ID3D11Resource interface of destination");
		}

		var source: *d3d11.Resource;
		if shared_image.texture.vtable.query_interface(shared_image.texture, &guid_d3d11_resource, &source as *addr) != 0 {
			panic("Failed to query ID3D11Resource interface of source");
		}

		var src_box = d3d11.Box {
			left: 0,
			top: 0,
			front: 0,
			right: 1080,
			bottom: 1080,
			back: 1,
		};
		
		if shared_image.mutex.vtable.acquire_sync(shared_image.mutex, 1, winapi.INFINITE) != 0 {
			println("Failed to acquire mutex!");
		}

		self.device_context.vtable.copy_subresource_region(
			self.device_context,
			destination,
			0,
			0,
			0,
			0,
			source,
			0,
			&src_box,
		);

		self.swapchain.vtable.present(self.swapchain, 0, 0);
		
		if shared_image.mutex.vtable.release_sync(shared_image.mutex, 0) != 0 {
			println("Failed to release mutex!");
		}
	}

	pub func destroy(surface: *DisplaySurface) {
		memory.free(surface);
	}
}

@[dllexport]
func aethervr_display_surface_create(hwnd: winapi.Handle) -> *DisplaySurface {
	return DisplaySurface.create(hwnd);
}

@[dllexport]
func aethervr_display_surface_register_image(
	surface: *DisplaySurface,
	id: u32,
	target_process_id: winapi.Dword,
	shared_texture_handle: winapi.Handle,
) {
	surface.register_image(id, target_process_id, shared_texture_handle);
}

@[dllexport]
func aethervr_display_surface_present_image(surface: *DisplaySurface, id: u32) {
	surface.present_image(id);
}

@[dllexport]
func aethervr_display_surface_destroy(surface: *DisplaySurface) {
	DisplaySurface.destroy(surface);
}
