use std.{system.panic, memory};
use windows as winapi;

struct SharedImage {
    var id: u32;
    var texture: *winapi.ID3D11Texture2D;
    var mutex: *winapi.IDXGIKeyedMutex;
}

struct DisplaySurface {
    var device1: *winapi.ID3D11Device1;
    var device_context: *winapi.ID3D11DeviceContext;
    var buffer: *winapi.ID3D11Texture2D;
    var swapchain: *winapi.IDXGISwapChain1;
    var images: Array[SharedImage];

    pub func create(hwnd: winapi.HANDLE) -> *DisplaySurface {
        var factory: *winapi.IDXGIFactory2;

        if winapi.CreateDXGIFactory1(&winapi.IDXGIFactory2_Guid, &factory as **void) != 0 {
            panic("Failed to create DXGI factory");
        }

        var adapter: *winapi.IDXGIAdapter;

        if factory.EnumAdapters(0, &adapter) != 0 {
            panic("Failed to find a DXGI adapter");
        }

        factory.Release();

        var desc: winapi.DXGI_ADAPTER_DESC;

        if adapter.GetDesc(&desc) != 0 {
            panic("Failed to get DXGI adapter description");
        }

        print("Using adapter with LUID ");
        println(desc.AdapterLuid);

        var feature_level = winapi.D3D_FEATURE_LEVEL.D3D_FEATURE_LEVEL_11_1;
        var device: *winapi.ID3D11Device;
        var device_context: *winapi.ID3D11DeviceContext;

        if winapi.D3D11CreateDevice(
            adapter,
            winapi.D3D_DRIVER_TYPE.D3D_DRIVER_TYPE_UNKNOWN,
            null,
            2,
            &feature_level,
            1,
            7,
            &device,
            null,
            &device_context
        ) != 0 {
            panic("Failed to create D3D11 device");
        }

        println("Device created");

        var device_as_device1: *winapi.ID3D11Device1;
        var device_as_iunknown: *winapi.IUnknown;

        if device.QueryInterface(&winapi.ID3D11Device1_Guid, &device_as_device1 as **void) != 0 {
            panic("Failed to access ID3D11Device1 interface of device");
        }

        if device.QueryInterface(&winapi.IUnknown_Guid, &device_as_iunknown as **void) != 0 {
            panic("Failed to access IUnknown interface of device");
        }

        var swapchain_desc = winapi.DXGI_SWAP_CHAIN_DESC1 {
            Width: 1080,
            Height: 1080,
            Format: winapi.DXGI_FORMAT.DXGI_FORMAT_R8G8B8A8_UNORM,
            Stereo: 0,
            SampleDesc: winapi.DXGI_SAMPLE_DESC {
                Count: 1,
                Quality: 0,
            },
            BufferUsage:
                # d3d11.DXGI_USAGE_RENDER_TARGET_OUTPUT as u32 |
                winapi.DXGI_USAGE_UNORDERED_ACCESS as u32,
            BufferCount: 2,
            SwapEffect: winapi.DXGI_SWAP_EFFECT.DXGI_SWAP_EFFECT_FLIP_DISCARD,
            Scaling: winapi.DXGI_SCALING.DXGI_SCALING_STRETCH,
            AlphaMode: winapi.DXGI_ALPHA_MODE.DXGI_ALPHA_MODE_UNSPECIFIED,
            Flags: 0,
        };

        var swapchain: *winapi.IDXGISwapChain1;

        if factory.CreateSwapChainForHwnd(device_as_iunknown, hwnd, &swapchain_desc, null, null, &swapchain) != 0 {
            panic("Failed to create swapchain");
        }

        println("Swapchain created");

        var buffer: *winapi.ID3D11Texture2D;

        if swapchain.GetBuffer(0, &winapi.ID3D11Texture2D_Guid, &buffer as **void) != 0 {
            panic("Failed to get swapchain buffer");
        }

        println("Got swapchain buffer");

        return memory.box(DisplaySurface {
            device1: device_as_device1,
            device_context: device_context,
            buffer: buffer,
            swapchain: swapchain,
            images: [],
        });
    }

    pub func register_image(
        self,
        id: u32,
        target_process_id: u32,
        shared_texture_handle: winapi.HANDLE,
    ) {
        var process = winapi.OpenProcess(0x40, 0, target_process_id);

        if process == null {
            panic("Failed to open target process");
        }

        println("Opened target process");

        var local_handle: addr = null;

        if winapi.DuplicateHandle(
            process,
            shared_texture_handle,
            winapi.GetCurrentProcess(),
            &local_handle,
            0,
            0,
            0x2
        ) == 0 {
            panic("Failed to duplicate handle");
        }

        println("Handle duplicated");

        if winapi.CloseHandle(process) == 0 {
            panic("Failed to close process handle");
        }

        println("Process handle closed");

        var texture: *winapi.ID3D11Texture2D;

        if self.device1.OpenSharedResource1(local_handle, &winapi.ID3D11Texture2D_Guid, &texture as **void) != 0 {
            panic("Failed to open foreign texture");
        }

        println("Opened foreign texture");

        var mutex: *winapi.IDXGIKeyedMutex;

        if texture.QueryInterface(&winapi.IDXGIKeyedMutex_Guid, &mutex as **void) != 0 {
            panic("Failed to access IDXGIKeyedMutex interface of mutex");
        }

        self.images.append(SharedImage { id, texture, mutex });
    }

    pub func present_image(self, id: u32) {
        var shared_image: *SharedImage = null;

        for *image in self.images {
            if image.id == id {
                shared_image = image;
            }
        }

        if shared_image == null {
            return;
        }

        var destination: *winapi.ID3D11Resource;

        if self.buffer.QueryInterface(&winapi.ID3D11Resource_Guid, &destination as **void) != 0 {
            panic("Failed to query ID3D11Resource interface of copy destination");
        }

        var source: *winapi.ID3D11Resource;

        if shared_image.texture.QueryInterface(&winapi.ID3D11Resource_Guid, &source as **void) != 0 {
            panic("Failed to query ID3D11Resource interface of copy source");
        }

        var source_box = winapi.D3D11_BOX {
            left: 0,
            top: 0,
            front: 0,
            right: 1080,
            bottom: 1080,
            back: 1,
        };

        if shared_image.mutex.AcquireSync(1, winapi.INFINITE) != 0 {
            println("Failed to acquire mutex!");
        }

        self.device_context.CopySubresourceRegion(destination, 0, 0, 0, 0, source, 0, &source_box);
        self.swapchain.Present(0, 0);

        if shared_image.mutex.ReleaseSync(0) != 0 {
            println("Failed to release mutex!");
        }
    }

    pub func destroy(surface: *DisplaySurface) {
        memory.free(surface);
    }
}

@[dllexport]
func aethervr_display_surface_create(hwnd: winapi.HANDLE) -> *DisplaySurface {
    return DisplaySurface.create(hwnd);
}

@[dllexport]
func aethervr_display_surface_register_image(
    surface: *DisplaySurface,
    id: u32,
    target_process_id: u32,
    shared_texture_handle: winapi.HANDLE,
) {
    surface.register_image(id, target_process_id, shared_texture_handle);
}

@[dllexport]
func aethervr_display_surface_present_image(surface: *DisplaySurface, id: u32) {
    surface.present_image(id);
}

@[dllexport]
func aethervr_display_surface_destroy(surface: *DisplaySurface) {
    DisplaySurface.destroy(surface);
}
