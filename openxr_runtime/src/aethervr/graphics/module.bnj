use std.{memory, config};

use xr;

use aethervr.{
    log,
    swapchain.SwapchainImage,
    graphics.{vulkan, d3d11, metal},
};

struct ImageRegion {
    var x: i32;
    var y: i32;
    var width: i32;
    var height: i32;
    var array_index: u32;
}

struct ImageData {
    var width: u32;
    var height: u32;
    var data: Array[u8];
}

struct SharedImage {
    var process_id: u32;
    var texture_handle: addr;
}

proto GraphicsBackend {
    pub func new(info: *xr.SessionCreateInfo) -> ?*GraphicsBackend {
        # TODO: Free the memory allocated here.

        var next = info.next as *xr.BaseInStructure;

        meta if config.OS == config.WINDOWS || config.OS == config.LINUX {
            if next.type_ == xr.StructureType.GRAPHICS_BINDING_VULKAN_KHR {
                log.info("Graphics binding: Vulkan");

                var binding = next as *xr.GraphicsBindingVulkanKHR;
                return memory.box(VulkanBackend.new(*binding));
            }
        }
        
        meta if config.OS == config.WINDOWS {
            if next.type_ == xr.StructureType.GRAPHICS_BINDING_D3D11_KHR {
                log.info("Graphics binding: D3D11");

                var binding = next as *xr.GraphicsBindingD3D11KHR;
                return memory.box(D3D11Backend.new(*binding));
            }
        }

        meta if config.OS == config.MACOS {
            if next.type_ == xr.StructureType.GRAPHICS_BINDING_METAL_KHR {
                log.info("Graphics binding: Metal");

                var binding = next as *xr.GraphicsBindingMetalKHR;
                return memory.box(MetalBackend.new(*binding));
            }
        }

        log.error("Graphics binding is unsupported");
        return none;
    }

    func get_supported_formats(self) -> [i64];
    func create_image(self, info: *xr.SwapchainCreateInfo, image: *SwapchainImage) -> xr.Result;
    func store_image(self, handle: usize, out_images: *xr.SwapchainImageBaseHeader, out_index: u32);
    func copy_image_to_host(self, image: *SwapchainImage, region: ImageRegion) -> ?ImageData;
    
    func share_image(self, image: *SwapchainImage) -> ?SharedImage {
        return none;
    }
    
    func acquire_image(self, image: *SwapchainImage) {}
    func release_image(self, image: *SwapchainImage) {}
}

meta if config.OS == config.WINDOWS || config.OS == config.LINUX {
    struct VulkanBackend: GraphicsBackend {
        var binding: xr.GraphicsBindingVulkanKHR;

        pub func new(binding: xr.GraphicsBindingVulkanKHR) -> VulkanBackend {
            return VulkanBackend { binding };
        }

        pub func get_supported_formats(self) -> [i64] {
            return vulkan.get_supported_formats();
        }

        pub func create_image(self, info: *xr.SwapchainCreateInfo, image: *SwapchainImage) -> xr.Result {
            return vulkan.create_swapchain_image(info, &self.binding, image);
        }

        pub func store_image(self, handle: usize, out_images: *xr.SwapchainImageBaseHeader, out_index: u32) {
            var out_images_vulkan = out_images as *xr.SwapchainImageVulkanKHR;
            out_images_vulkan[out_index].image = handle as addr;
        }
        
        pub func copy_image_to_host(self, image: *SwapchainImage, region: ImageRegion) -> ?ImageData {
            return vulkan.copy_image_to_host(&self.binding, image, region);
        }
    }
}

meta if config.OS == config.WINDOWS {
    struct D3D11Backend: GraphicsBackend {
        var binding: xr.GraphicsBindingD3D11KHR;

        pub func new(binding: xr.GraphicsBindingD3D11KHR) -> D3D11Backend {
            return D3D11Backend { binding };
        }

        pub func get_supported_formats(self) -> [i64] {
            return d3d11.get_supported_formats();
        }

        pub func create_image(self, info: *xr.SwapchainCreateInfo, image: *SwapchainImage) -> xr.Result {
            return d3d11.create_swapchain_image(info, &self.binding, image);
        }

        pub func store_image(self, handle: usize, out_images: *xr.SwapchainImageBaseHeader, out_index: u32) {
            var out_images_d3d11 = out_images as *xr.SwapchainImageD3D11KHR;
            out_images_d3d11[out_index].texture = handle as addr;
        }

        pub func acquire_image(self, image: *SwapchainImage) {
            d3d11.acquire_image(&self.binding, image);
        }

        pub func release_image(self, image: *SwapchainImage) {
            d3d11.release_image(&self.binding, image);
        }
        
        pub func copy_image_to_host(self, image: *SwapchainImage, region: ImageRegion) -> ?ImageData {
            return d3d11.copy_image_to_host(&self.binding, image, region);
        }

        pub func share_image(self, image: *SwapchainImage) -> ?SharedImage {
            return d3d11.share_image(&self.binding, image);
        }
    }
}

meta if config.OS == config.MACOS {
    struct MetalBackend: GraphicsBackend {
        var binding: xr.GraphicsBindingMetalKHR;

        pub func new(binding: xr.GraphicsBindingMetalKHR) -> MetalBackend {
            return MetalBackend { binding };
        }

        pub func get_supported_formats(self) -> [i64] {
            return metal.get_supported_formats();
        }

        pub func create_image(self, info: *xr.SwapchainCreateInfo, image: *SwapchainImage) -> xr.Result {
            return metal.create_swapchain_image(info, &self.binding, image);
        }

        pub func store_image(self, handle: usize, out_images: *xr.SwapchainImageBaseHeader, out_index: u32) {
            var out_images_metal = out_images as *xr.SwapchainImageMetalKHR;
            out_images_metal[out_index].texture = handle as addr;
        }

        pub func copy_image_to_host(self, image: *SwapchainImage, region: ImageRegion) -> ?ImageData {
            return none;
        }
    }
}
